{"./":{"url":"./","title":"笔记介绍","keywords":"","body":"Introduction 这是一份个人笔记。 ​ --------WY powered by Gitbook该文件修订时间： 2018-12-26 11:26:23 "},"JS/":{"url":"JS/","title":"JavaScript","keywords":"","body":" JavaScript概述 语法、关键保留字、变量 数据类型 运算符 控制流程语句 函数 对象和数组 时间与日期 正则表达式 函数 变量、作用域及内存 基本包装类型 内置对象 面向对象与原型 匿名函数与闭包 BOM 浏览器检测 DOM基础 DOM进阶 DOM操作表格及样式 DOM元素尺寸和位置 动态加载脚本和样式 事件入门 事件对象 事件绑定及深入 表单处理 错误处理与调试 cookie与存储 XML XPath JSON AJAX 博客-理解JS库对象 博客-连缀 是否改变原数组的常用方法归纳 powered by Gitbook该文件修订时间： 2018-12-26 11:25:34 "},"JS/day01/":{"url":"JS/day01/","title":"JavaScript概述","keywords":"","body":"JS菜鸟到大神成长之路 JS概述 定义：面向对象、解释型，基于对象和事件驱动的客户端脚本语言，为提交数据之前验证而生。 特点：松散性、对象属性、继承机制 组成部分： 核心ECMAScript：定义语言的基础，分为语法、类型、语句、关键字、保留字、对象 文档对象模型DOM：树，有级别，与浏览器兼容性火狐较好 浏览器对象模型BOM：控制浏览器显示页面页面的部分 用notepad++创建一张HTML页面 script标签解析 charset：不用 defer：不用 script定义顺序决定解析顺序 language：不用 src：可选 表示要执行的外部文件 type： 必须 表示代码使用的脚本语言类型 alert('hello world！'); 外部引用的js文件优点： 维护性高 可缓存（加载一次，无需多次加载） 方便未来扩展 注意事项： script必须是双标签 引入和内嵌两种形式都有的话只执行引用 外部引入文件可解决script标签结尾显示的问题。 头文件尽量放在title下面 无需注释 浏览器设置不支持js时中的内容可显示 因过于智能不用火狐6 powered by Gitbook该文件修订时间： 2018-08-20 21:48:00 "},"JS/day02/":{"url":"JS/day02/","title":"语法、关键保留字、变量","keywords":"","body":"语法、关键保留字及变量 区分大小写 标识符：函数、变量和属性的名字，组成： 第一个字符必须是字母、下划线或$ 其他组成再加数字 不能把关键字、保留字、true、false及null作为标识符 注释 //单行注释 / 多行注释 / 直接量（字面量） 数字字面量 100 字符串字面量 '王XX' 布尔值字面量 false 正则表达式字面量 /js/gi 对象字面量 null 对象字面量表达式 {x:1,y:2} 数组字面量表达式 [1,2,3,4,5] 关键字和保留字的区别：关键字是程序中已经开始使用的字符，保留字是将来可能会用做关键字。 声明和初始化： 虽然是松散性语言，也不建议改变变量存储的类型，这样会耗费资源，且变量名一般具有含义时不易维护。 无需加var关键字声明，作用域会不同，后面详细讲解 格式：var box = 'wy', age = 20, height; powered by Gitbook该文件修订时间： 2018-08-21 12:25:23 "},"JS/day03/":{"url":"JS/day03/","title":"数据类型","keywords":"","body":"1个操作符和6种数据类型 typeof操作符 返回如下字符串：//可以操作变量也可以操作字面量 alert(typeof '王XX'); Undefined 值为undefined，未经初始化的变量的值，在定义变量时，一定要给变量赋值 Null 值为null,表示一个空对象引用，但typeof null会返回object 初始化为null是为了保存对象 alert(undefined == null) //true alert(undefined === null) //false alert(typeof undefined == typeof null) //false Boolean true和false两个值 显式转换Boolean(变量名) 转换规则：Number 包括两种类型：整型和浮点型 整型 十进制字面量：var box = 100; 八进制字面量，前导必须为0,八进制序列0-7,无效时解析为十进制 十六进制字面量，前两位必须是0x，序列0-9，A-F 浮点类型 数值中必须包含一个小数点，且小数点后至少有一位数字，前不能加0 科学计数法表示: 4.12e9 不要做精确判断 最大值：Number.MAX_VALUE 超出为Infinity 即Number.POSITIVE_INFINITY 最小值：Number.MIN_VALUE 超出为-Infinity 即Number.NEGATIVE_INFINITY 用isFinity(数值)的返回值true/false判断是否超过范围 转换：为浮点数分配的内存空间是整型的两倍，故ECMA自动将可以转换的浮点数转换成整型 NaN 一个值 isNaN(数值) 判断是否为NaN isNaN(NaN) true isNaN(可以转换成Number的任何值) false isNaN(true) false 转换为1 isNaN()也适用于对象,先调用valueOf(),确定是否可以转换成数值，不能则调用toString方法，再次测试能否转换成数值。var box={}; alert(isNaN(box)); //true var box1={ toString:function(){ return '123'; } }; alert(isNaN(box1)); //false 非数值转换成数值：Number()、parseInt()、parseFloat();Number()用于任何类型的转换，后两个专门用于字符串转换。 Number() 对于只包含数字的字符串，默认转换为10进制 只包含浮点型的字符串，默认去掉前面的0和后面的0 空字符串，返回0 不是纯数字，返回NaN 是对象的话，与上面的isNaN雷同，通过toString方法转换 parseInt() 只能转换字符串 默认从前面开始解析，遇到字母则NaN，数字则解析到不是数字为止 识别八进制以及十六进制的转换 parse( , )：第二个参数为进制数2/8/16，此时前导可去掉 parseFloat() 不认识十六进制 只认一个小数点 去掉前后导 String 由双引号和单引号保存均可，不穿插使用就可以，ECMA都可以解析。 包含特殊的字符字面量 ECMA中字符串不能改变，只能重新创建然后重新指向 toString() 无需传参 只有进制可以传参，toString(8)八进制输出 若转型前不知道是否为null或者undefined，可以调用转型函数String(变量名)，它能将任何类型的值转换为字符串。 Object 初始化 1.var box = null; 2.var box = {}; 3.var box = new Object(); //通过new创建一个对象，可以通过构造函数传递任意类型参数 可以和普通变量运算 var box = new Object(2); var age = box + 100; alert(age); //102 通过new来创建其他类型的对象String、Number,但实际是数值对象。 powered by Gitbook该文件修订时间： 2018-09-01 15:20:13 "},"JS/day04/":{"url":"JS/day04/","title":"运算符","keywords":"","body":"运算符 表达式：是指单一的字面量和组合字面量的运算符。 一元运算符：只操作一个值的运算符。 递增++和递减-- 前置和后置的区别：前置：先赋值后++；后置：先++后赋值 其他类型使用一元运算符时： 数值字符串自动转换为数值 非数值字符串输出NaN false ++后就是1 对象在设置toString方法后正常输出，否则为NaN +号：除了运算以外，亦可以类型转换，+变量名，转换方式与上雷同 -号：除了运算以外，亦可以类型转换，-变量名，转换成对应的负值，方式与上雷同 算术运算符 NaN与任何运算都为NaN Infinity也可以参与运算，注意：+Infinity+-Infinity为NaN 加法运算：+除了运算以外，还可当做字符串连接符，按照顺序解析，可通过括号改变顺序 数值和没有toString为数值的对象+之后，类型为String类型 减法运算： 100 - '' = 100 100 - null = 100 100 - NaN = NaN 100 - 对象 = 取决于toString方法 乘法运算： 100 true = 100 100 * '' = 0 100 * null = 0 100 * 'Lee' = NaN 100 * 对象=取决于toString 除法运算： Infinity的运算都为NaN 100 / true = 100 100 / '' = Infinity 100 / null = Infinity 100 / 'Lee' = NaN 100 / 对象 = 取决于toString 求模运算 和NaN以及Infinity的求模为NaN 100 % '' = NaN 100 % null = NaN 100 % 'Lee' = NaN 100 % 对象 = 取决于toString 关系运算符：用于比较的运算符（> = == === ） 结果返回布尔值 都是数值，正常比较 都是字符串，比较对应的字符编码值 只有一个数值字符串，可转换 两个都是数值字符串，只会进行第一个字符的比较 有一个是对象，取决于该对象的toString方法 逻辑运算符&& 第一个是对象，则返回第二个操作数 第二个是对象，第一个是true就返回第二个对象，否则返回false 有一个为null,则为null 有undefined ,则返回undefined 短路特性，第一个结果是false，则不执行第二个 逻辑或|| 一边是true,整体为true 第一个是对象，返回第一个操作数 第一个结果为false，返回第二个操作数 都是对象，返回第一个操作数 都是null，返回null 都是NaN,返回NaN 都是undefined ,返回undefined 逻辑非！先将这个值转换成布尔值，再取反 对象 false '' true 'wes' false 0 true 34 false null true NaN true undefined true 位运算符 位运算符 符号 位非 ~ 位与 & 位或 l 位亦或 ^ 左移 有符号右移 >> 无符号右移 >>> 赋值运算符= 逗号运算符：对多个变量（数组，对象）进行声明时连接 三元运算符：5 > 4 ? '对'：'错' 运算符的优先级 赋值运算符优先级很低 powered by Gitbook该文件修订时间： 2018-09-01 15:23:32 "},"JS/day05/":{"url":"JS/day05/","title":"控制流程语句","keywords":"","body":"流程控制语句 单行语句 复合语句，又称代码块，一对括号为一个复合语句，当做一条单行语句处理 { var height=200; var width=300; } 1.if语句 if()中的内容自动转换成布尔值 2.swich语句 for-in语句：精准的迭代语句，用来枚举对象的属性 var box = { 'name' : 'WY', 'age' : 22. 'height' : 180 } for(var x in box){ alert(x); } break与continue的区别 break:退出循环 continue：退出当前循环，回到循环初始 with语句：将代码中的作用域设置到一个特定的对象中 var box = { //创建一个对象 'name' : 'WY', 'age' : 22. 'height' : 180 } //常规写法 var n=name; var a=age; var h=height; with(box){ var n=name; //这里的name相当于box.name var a=age; //省略了box对象名 var h=height; } powered by Gitbook该文件修订时间： 2018-09-01 15:25:26 "},"JS/day06/":{"url":"JS/day06/","title":"函数","keywords":"","body":"函数 学习要点： 函数声明 return返回值 arguments对象 函数声明 注意：函数本身没有运行功能，需要被调用 function box(){ alert('我只有被调用才可以执行')； } box(); return函数 除了必要时返回数据，还有一个功能是退出函数 function box(){ return '我只有被调用才可以执行'; }1 arguments对象 可以不写形参，默认被放到arguments对象数组中 function box(){ return arguments[0]+'|'+arguments[1]+'|'; } box('王XX',22) 属性length：动态的累加 function box(){ var sum = 0; for(var i = 0; i ==注意== ：函数不具备重载功能，重名函数会默认后面覆盖前面的函数 powered by Gitbook该文件修订时间： 2018-08-21 21:24:14 "},"JS/day07/":{"url":"JS/day07/","title":"对象和数组","keywords":"","body":"对象和数组（上） 学习要点： Object类型 Array类型 对象中的方法 Object类型 对象两种创建方式及两种输出方式 //new关键字创建对象 var box1 = new Object(); box1.name = '王XX'; //字面量创建对象（不调构造） var box2 = { 'name':'王XX', //属性可以用字符串表示 age:22 } //输出方式 alert(box['name']); //用数组的方式输出一定要加引号 alert(box.name); 方法的创建 var box = { name : '王XX'， run : function(){ return '123'; } }; alert(box.ren); //无圆括号会打印代码 alert(box.run()); //有圆括号会打印返回值 delete box.name; //删除属性用delete //字面量创建方式较为常用 var obj{ name : 'WY', age : 22, height : 180 }; function print(obj){ if(obj.name != undifined) alert(obj.name); //加判断 if(obj.love != undefined) alert(obj.love); } print(obj); Array类型 var arr = new Array(); //声明一个数组 alert(type.box); var arr = new Array('王XX','22','女'); //创建一个数组 alert(arr[2]); var arr = new Array(10); //创建固定数目的数组，该参数必须是数字，且只能为一个参数 arr[3] = '王XX'; arr[5] = '女'; var arr = Array(); //该方式省略了new关键字 var box = []; //字面量的方式创建数组 var box = ['wy',22]; //字面量的方式创建了数组并初始化 //创建一个复杂数组 var box = [ { name:'wy', age:22 }, [3,4,5,'陕西',new Object()], '计算机编程', neww Array(1,2,3) ]; alert(box[0].name); 对象和数组（下） //数组与对象都适用的方法 var box = ['wy','计算机编程',22]; alert(box.toString()); alert(box.valueOf()); alert(box.toLocaleString()); //返当地标准时间 pop()和push() //栈方法 box.push('女'); box.pop(); //移除的元素数组末尾的元素并返回 box.shift(); //移除数组开头一个元素并返回 box.unshift('陕西'); //给数组开头添加一个元素 //重排序方法：reverse()和sort() var box=[3,5,2,7,6,0,7]; //sort():从小到大排序 box.sort(); //reverse():逆向排序，会对引用进行操作,即改变数组 box.reverse(); concat()：基于当前数组创建一个新数组 slice()：获取指定区域的元素，返回新数组 splice()：对数组插入元素 var box = ['wy',33,'计算机编程','女']; var box1 = box.concat('通信'); //concat()返回新的数组 var box2 = box.slice(1,3); //从第一个位置取到第三个位置 //删除功能 var box3 = box.splice(0,2); //从第0个位置取(删除)两个 //插入功能 var box4 = box.splice(1,0,'陕西'); //从第一个位置插入元素0表示不删除 //替换功能 var box5 = box.splice(1,1,100); //从第一个位置截取了一个加100，也就是替换 powered by Gitbook该文件修订时间： 2018-09-01 15:28:12 "},"JS/day08/":{"url":"JS/day08/","title":"时间与日期","keywords":"","body":"时间与日期 学习要点： Date类型 通用的方法 格式化方法 组件方法 parse和UTC //创建一个日期对象，参数可用来指定时间 var Date = new Date(); alert(Date.parse('4/12/2018')); //第一种写法：'月/日/年' 返回一个毫秒数 alert(Date.parse()); //不传参，返回NaN var box = new Date('wdss243') //乱写的日期返回无效的日期 var box = new Date('May25,2017') //第二种写法 var box = new Date('The Apr 12 2007 22:22:22 GMT+0800'); //第三种写法 var box = new Date('Junuary 32,2007'); //不报错，会将多出来的累加到下一个月 //必须传入年份和月份 alert(Date.UTC()); //返回毫秒数 alert(Date.UTC(2007,10)); //UTC世界协调时间，按照他的区域基准计算：Fri Nov 16 2007 01:22:45 GMT+0800 var box = new Date(Date.UTC(2007,10,15,17,22,45,15)); //返回本地时间 var box = new Date(2007,10,15,17,22,45,15); 时间与日期（下） var box = new Date(2017,11,6,13,45,45); alert(box); //东八区格式 alert('toString'+box.toString()); //东八区格式 alert('toLocaleString'+box.toLocaleString()); //本地化格式，更好看懂 alert(box.valueOf()); //返回毫秒数 以上常用的是.toLocaleString(),返回本地格式 var box = new Date(2017,11,6,13,45,45); alert(box.toDateString()); //Wed Dec 06 2017 alert(box.toTimeString()); //13:45:45 GMT+0800(中国标准时间) alert(box.toLocaleDateString()); //2017/12/16 alert(box.toLocaleTimeString()); //下午1:45:45 alert(box.toUTCString()); //世界统一时间，8个小时时差 以上常用的是.toLocaleDateString()和toLocaleTimeString(),返回本地格式的日期和时间 组件时间 //组件时间 var box = new Date(2017,11,6,13,45,45); alert(box.getTime()); //毫秒数 //年 alert(box.getFullYear()); //2017 box.setFullYear(2019); alert(box.getFullYear()); //2019 var box = new Date(2017,11,6,13,45,45); //月 alert(box.getMonth()); //与视频中不同的是，无需+1 box.setMonth(5); alert(box.getMonth());*/ var box1 = new Date(); //不传参数，即当前时间 alert(box1.getMonth()+1); //月份时要+1才是当前月份 注意不传参数时月份默认从0开始，要+1 //UTC功能 var box = new Date(2017,11,6,13,45,45); alert(box.getUTCFullYear()); //均无差异 alert(box.getUTCHours()); //-8，会有8个小时时差 var box = new Date(2017,11,6,13,45,45); alert(box.getTimezoneOffset()); //返回本地时间与UTC时间相差的分钟数-480=-8*60 var box = new Date(); alert(box.getFullYear()+'-'+box.getMonth()+'-'+box.getDate()+' '+box.getHours()+':'+box.getMinutes()+':'+box.getSeconds()); 以上除了getTimezoneOffset之外都具有UTC功能 powered by Gitbook该文件修订时间： 2018-09-01 15:29:53 "},"JS/day09/":{"url":"JS/day09/","title":"正则表达式","keywords":"","body":"正则表达式（上） 学习要点 创建方式 参数的意义 匹配的方法 作用：用来验证输入客户端的输入数据，客户端的验证，可以节约大量的服务器端的系统资源 创建正则的两种方式 方式一：new关键字 var reg = new RegExp('Box'); //第一个参数是模式字符串 alert(reg); //输出/Box/是正则表达式的字面量表示法 var reg = new RegExp('Box','gi'); //第二个参数可选：模式修饰符 模式匹配的可选参数 参数 含义 i 忽略大小写 g 全局匹配 m 多行匹配 方式二：字面量方式 var pattern = /Box/ig; var str = 'box'; alert(pattern.test(str)); 匹配正则表达式的方法 RegExp对象的方法 方法 功能 test 在字符串中测试模式匹配，返回true或者false exec 在字符串中执行匹配搜索，返回结果数组 test()用法 var pattern = new RegExp('Box'); //模式 var str = 'box'; //字符串 alert(pattern.test(str)); //返回的是false,因为大小写不一致 var pattern = new RegExp('Box','i'); var str = 'box'; alert(pattern.test(str)); //忽略大小写就返回true alert(/Box/i.test('box')); //一句话匹配 var pattern = /Box/i; var str = 'This is a box'; alert(pattern.test(str)); //是字符串==所做不到的 exec()用法 var pattern = /Box/i; var str = 'box'; alert(pattern.exec(str)); //匹配到返回匹配到的数组 var str1 = 'sss'; alert(pattern.exec(str1)); //匹配不到返回null alert(typeof pattern.exec(str)); //返回的是Object 正则表达式 学习要点 String对象中的正则方法 RegExp的静态属性 RegExp的实例属性 String对象中的正则表达式方法 方法 含义 match(pattern) 返回pattern中的子串或null replace(pattern,replacement) 用replacement替换pattern search(pattern) 返回字符串中pattern开始位置 split(pattern) 返回字符串按指定pattern拆分的数组 //作用：将匹配的字符串组合成数组返回 /*var pattern = /Box/i; var str = 'This is a Box!That is a Box！'; alert(str.match(pattern));*/ //返回第一个匹配的位置，无需g全局 /*var pattern = /Box/i; var str = 'This is a box!That is a Box!'; alert(str.search(pattern));*/ //返回替换后的字符串，与是否全局有关,只有替换，是两个参数 /*var pattern = /Box/g; var str = 'This is a Box! That is a Box！'; alert(str.replace(pattern,'Tom'));*/ //把一个字符串用正则表达式拆分成数组 var pattern = /Box/i; var str = 'This is a Box!That is a Box！'; alert(str.split(pattern)); //返回分割后的数组This is a ,!Thatis a ,! alert(str.split(pattern).length); //长度为3 var pattern = /!/i; var str = 'This is a Box!That is a Box!'; alert(str.split(pattern)); //输出This is a Box,That is a Box, alert(str.split(pattern).length); //长度为3 RegExp对象的静态属性 属性 短名 含义 input $_ 当前被匹配的字符串 lastMatch $& 最后一个匹配字符串 lastParen $+ 最后一对圆括号内的匹配子串 leftContext $` 最后一次匹配前的子串 multiline $* 用于指定是否所有表达式都用于多行匹配的布尔值 rightContext $' 在上次匹配之后的子串 使用： var pattern = /Bo(x)/gi; var str = 'hello Box！'; pattern.test(str); //静态属性，必须先执行，才有效 alert(RegExp.input); //hello Box! alert(RegExp.lastMatch); //Box alert(RegExp.leftContext); //hello alert(RegExp.rightContext); //! alert(RegExp.multiline); //undefined alert(RegExp.lastParen); //x alert(RegExp['$_']); RegExp的实例属性 属性 含义 global Boolean值，表示g是否已设置 ignoreCase Boolean值，表示i是否已设置 lastIndex 整数，代表下次匹配将从哪里字符位置开始 multiline Boolean值，表示m是否已设置 source 正则表达式的源字符串形式 使用： var pattern = /Box/igm; var str = 'hello box!'; alert(pattern.global); //true alert(pattern.ignoreCase); //true pattern.test(str); alert(pattern.lastIndex); //9 alert(pattern.multiline); //true alert(pattern.source); //Box 正则表达式 学习要点： 获取控制 正则表达式元字符包含特殊含义：可以控制匹配模式的方式 元字符/元符号 匹配情况 . 匹配除换行符外的任意字符 [a-z] 匹配括号中的字符集中的任意字符 a-z 不在括号中的字符集中的字符 \\d 匹配数字 \\D 匹配非数字 \\w 匹配字母数字以及下划线 \\W 匹配非字母非数字以及非下划线 空白字符 元字符/元符号 匹配情况 \\0 匹配null字符 \\b 匹配空格字符 \\f 匹配进制字符 \\n 换行符 \\r 回车字符 \\s 空白字符、空格、制表符和换行符 \\S 匹配非空白字符 锚字符 元字符/元符号 匹配情况 ^ 行首匹配 $ 行尾匹配 重复字符 元字符/元符号 匹配情况 x? 匹配0个或多个x x* 0个1个或多个 x+ 1个或多个 (xyz)+ 至少匹配一个(xyz) x{m,n} 最少m个，最多n个x x{m} 匹配m个 正则表达式 记录字符 元字符/元符号 匹配情况 (string) 用于反向引用的分组 \\1或$1 匹配第一个分组中的内容 \\2或$2 匹配第二个分组中的内容 \\3或$3 匹配第三个分组中的内容 \\s、\\b、{n,m}、|、()的用法 var pattern = /goo\\sgle/; //\\s表示空格匹配 var str = 'goo gle'; alert(pattern.test(str)); var pattern = /google\\b/; //\\b匹配是否到达边界 var str = 'google'; alert(pattern.test(str)); var pattern = /google|baidu|taobao/; var str = 'google'; var str = 'This is baidu'; alert(pattern.test(str)); //true var pattern = /google{4,8}/; //匹配e4-8次 var str = 'googleeeeee'; alert(pattern.test(str)); var pattern = /(google){4,8}/; //匹配google4-8次，分组的作用 var str = 'googlegooglegooglegoogle'; alert(pattern.test(str)); $1获取匹配到的内容 var pattern = /8(.*)8/; var str = '8google8'; pattern.test(str) alert(RegExp.$1); //输出google表示获取模式中第一个分组对应的匹配字符串 var pattern = /8(.*)8/; var str = 'It is 8what we want strong8!'; pattern.test(str); //$1获取第一个分组匹配到的字符串 document.write(str.replace(pattern,'$1')); //document.write()可以将括号中的内容显示在网页上 var pattern = /(.*)\\s(.*)/; var str = 'hello world'; document.write(str.replace(pattern,'$2 $1')); //位置交换 贪婪和惰性 贪婪 惰性 + +? ? ?? * *? {n} {n}? {n,} {n,}? {n,m} {n,m}? var pattern = /[a-z]+/; //贪婪模式：匹配所有字符 var str = 'helloworld'; document.write(str.replace(pattern,'1')); //1 var pattern = /[a-z]+?/; //惰性模式：只匹配上了一个字符 var str = 'helloworld'; document.write(str.replace(pattern,'1')); //1elloword var pattern = /[a-z]+/g; //全局下的贪婪：匹配所有字符 var str = 'helloworld'; document.write(str.replace(pattern,'1')); //1 var pattern = /[a-z]+?/g; //全局下的惰性：匹配一个字符 var str = 'helloworld'; document.write(str.replace(pattern,'1')); //1111111111每一个字符都被替换成了1 var pattern = /8(.*)8/; //使用了贪婪 var str = '8google88google88google8'; document.write(str.replace(pattern,'$1'));//匹配到了所有，均被加粗 禁用贪婪的两种方式1.？2.[ ^前一个字符] var pattern = /8(.*?)8/g; //1.禁用贪婪 var str = '8google8 8google8 8google8'; document.write(str.replace(pattern,'$1')); //google google google var pattern = /8([^8].*?)8/g; //2.禁用贪婪 var str = '8google8 8google8 8google8'; document.write(str.replace(pattern,'$1')); //google google google 使用exec返回数组 使用分组的exec返回数组的方式 var pattern = /^([a-z]+)\\s([0-9]{4})$/; var str = 'google 2012'; var a = pattern.exec(str); //返回匹配到的数组 alert(a.length); //3 alert(a[0]); //返回匹配到的整个字符串 alert(a[1]); //返回匹配到的第一个分组的字符串 alert(a[2]); //返回匹配到的第二个分组的字符串 捕获性分组 var pattern = /(\\d+)([a-z])/; //捕获性分组，所有的分组都捕获返回 var str = '123abc'; alert(pattern.exec(str)); //a[0]返回123a //a[1]返回123 //a[2]返回a 非捕获性分组(?:) var pattern = /(\\d+)(?:[a-z])/; //非捕获性分组，在不需要捕获的分组加上？： var str = '123abc'; alert(pattern.exec(str)); //a[0]返回123a //a[1]返回123 嵌套分组 //嵌套分组 一般不用 var pattern = /(a?(b?(c?)))/; var str = 'abc'; alert(pattern.exec(str)); //第一步：a[0],整个匹配到的字符串abc //第二步：a[1],匹配第一个分组(a?(b?(c?))),abc //第二步：a[2],匹配第二个分组(b?(c?)),bc //第三步：a[3],匹配第三个分组(c?),c 前瞻匹配 var pattern = /goo(?=gle)/; //前瞻性匹配：goo后面必须是gle才会返回goo,注意返回值是goo,不是gle //var str = 'goobb'; //null var str = 'google'; alert(pattern.exec(str)); 特殊字符的匹配 var pattern = /\\[/; var str = '['; alert(pattern.exec(str)); var pattern = /^\\d+/gm; //要开启换行模式，否则只能替换第一个数字 var str = '1.baidu\\n2.google\\n3.bing'; alert(str.replace(pattern,'#')); 正则的简单运用 //1.检查邮政编码 var str = '224000'; //必须是6位必须是数字，第一位不能为0 var pattern = /[1-9][0-9]{5}/; alert(pattern.test(str)); //3 删除多余空格 var str = '123 345 12'; var pattern = /\\s/g; alert(str.replace(pattern,'')); //4.1删除首尾空格(首尾分开匹配)繁琐 var str = ' 123 345 12 '; var pattern = /^\\s+/; var result = str.replace(pattern,''); pattern = /\\s+$/; result = result.replace(pattern,''); alert('|'+result+'|'); //4.2非贪婪模式去除首尾空格 var str = ' 123 45 '; var pattern = /^\\s+(.+?)\\s+$/; alert('|'+pattern.exec(str)[1]+'|'); //4.3分组模式去除首尾空格 var str = ' 123 45 '; var pattern = /^\\s+(.+?)\\s+$/; alert(str.replace(pattern,'$1')); //5.电子邮件验证 var str = 'yaoxxx@xxx.com'; //@不需要转义吗？ var pattern = /^([\\w\\.\\-]+)@([\\w\\-]+)\\.([a-zA-Z]{2,4})$/; alert(pattern.test(str)); //2.检查文件压缩包 var str = '213.rar'; //字母数字下划线，zip/gz/rar/7z var pattern = /^[\\w]+\\.(zip|gz|rar)$/; //选择符必须必须用分组符号包括起来 alert(pattern.exec(str)); powered by Gitbook该文件修订时间： 2018-09-02 21:33:17 "},"JS/day10/":{"url":"JS/day10/","title":"函数","keywords":"","body":"函数 学习要点： 三种声明方式：1.普通函数；2.变量初始化；3.new运算符 函数传递的两种方式 函数内部的两个对象：arguments和this 每个函数都包含的属性：length和prototype:apply()及call() 一、函数的声明 //1.普通函数声明 function box1(num1,num2){ return num1+num2; } alert(box1(1,2)); //2.使用变量初始化函数 var box2 = function(num1,num2){ return num1+num2; }; alert(box2(1,2)); //3.使用new运算符的构造函数来声明函数(不推荐) var box3 = new Function('num1','num2','return num1+num2'); alert(box3(1,2)); alert(typeof box3); //function 二、函数的传递 区别：1.将函数名与参数当做参数 2.将函数本身作为参数传递 //函数可以传递函数(与变量一样，函数名可以当做参数运算) function box(sum,num){ return sum+num; } function sum(num){ return num+10; } var result = box(sum(10),10); alert(result); //把函数本身作为参数传递，而不是函数结果 function sum(num){ return num+10; } function box(sum,num){ return sum(num); } alert(box(sum,10)); 三、函数内部的两个对象：arguments和this 1.arguments.callee();表示调用函数本身 function box(num){ if(num 2.window是一个对象，JS里最大的对象，全局状态下，this就是window this在对象中代表对象，在全局下代表window，在函数中也代表window 四、每个函数都包含的属性：length和prototype length:表示希望接收的参数个数 prototype下还有两个方法：call()和apply() apply(this,[参数1，参数2])冒充另一个函数，其中this表示window作用域,[]表示传递的参数，名字必须对应一致------>简化：apply(this,arguments) function box(num1,num2){ return num1+num2; } function sun(num1,num2){ return box.apply(this,[num1,num2]); } alert(sun(12,13)); call()与apply()区别：传参的方式不同call(this,参数1，参数2)，甚至无需传参 真正作用：扩展(改变)作用域:访问不同作用域下的相同属性 //全局下的属性 var color = '红色'; //对象内的属性 var box = { color:'蓝色' }; //通过this.color调用 function sayColor(){ alert(this.color); } // sayColor(); //红色 sayColor.call(box); //蓝色 sayColor.call(this); //红色 sayColor.call(window); //红色 用call实现无耦合调用三种作用域 powered by Gitbook该文件修订时间： 2018-08-29 12:50:29 "},"JS/day11/":{"url":"JS/day11/","title":"变量、作用域及内存","keywords":"","body":"变量、作用域及内存 学习要点： 1.变量及作用域 2.内存问题 一、变量及作用域 变量包含：基本类型值和引用类型值。基本类型值存于栈中；引用类型值是指存于堆中的对象 1.比较 变量类型 类型 大小 位置 基本类型 Undefined、Null、Boolean、Number、String 有固定大小 存于栈中 引用类型 Object 无固定大小 存于堆中 2.复制 PS:基本类型值不能添加属性 基本类型复制的是值本身，引用类型复制的是地址 //一改全改，因为指向同一个地址 var box = new Object(); box.name = 'Lee'; var box1 = box; alert(box1.name); //输出Lee 3.传递参数 所有函数参数都是按值传递的： 基本类型值作为参数传入方法之后原值均不改变 引用类型值作为参数按值传入方法而不是引用，但改变引用指向的值(属性)外面可以访问 function box(obj){ obj.name = 'Lee'; } var obj = new Object(); box(obj); alert(obj.name); //Lee 4.检测类型 typeof 用于检测基本类型，除非new出来的可以instanceof instanceof 用于检测引用类型（变量名 instanceof 类名） 5.作用域：全局执行环境被认为是window对象 全局变量，最外围，属于window属性 全局函数，最外围，属于window方法 外围函数中还有函数，从外部无法访问到 代码在环境中执行时，会形成作用域链，有序访问 if语句for语句的花括号没有作用域 变量访问中，搜索查询作用域链时访问局部变量更快，会优先访问同名的局部变量 二、内存 自动垃圾收集机制 常用收集方式：标记清除 优化内存：一旦不用了就赋值为null box = null; //销毁引用，等待垃圾收集器收集 powered by Gitbook该文件修订时间： 2018-08-29 18:45:16 "},"JS/day12/":{"url":"JS/day12/","title":"基本包装类型","keywords":"","body":"基本包装类型 学习要点： 概述 Boolean类型 Number类型 String类型 包装类型的作用： //不常用 var box = new String('Mr . yaoxxx'); box.name = 'yaoxxx'; box.age = function(){ return 100; }; alert(box); alert(typeof box); //Object alert(box.substring(2)); //从第二个位置开始截取到最后，索引从0开始 alert(box.name); //自定义属性 有效 alert(box.age()); //自定义方法 有效 Number类型 var box = 1000; |属性|描述| |---|---| |box.toString(); | //转化为字符串| |box.toLocaleString(); | //1,000| |box.toFixed(2); | //小数点后保留两位| |box.toExponential(); | //以指数形式表示并转化为字符串| |box.toPrecision(2); | //根据传参来决定指数或者点数 | String类型 String对象属性 |属性|描述| |---|---| |length|返回字符串的字符长度| |constructor|返回创建String对象的函数| |prototype|通过添加属性和方法扩展字符串定义| var box = 'Mr.yaoxxx'; |字符方法|描述| |---|---| |box.charAt(1);|返回指定下标的值| |box.charCodeAt(4)|返回指定位置字符的ASC码| 字符串操作方法 | 方法| 描述 | |--------|--------| |concat(str1,str2)|将字符串拼接|不改变原来的字符串 |slice(4,6)|从4到6前闭后开|不改变原来 |substring(4,6)|与slice()相同作用|不改变原来 |substr(4,6)|从4开始的6个字符|不改变原来 |slice(4)|同下 |substring(4)|从第四位开始的所有 |substr(4)|同上 字符串位置方法 | 方法 | 描述 | |--------|--------| | indexOf(str,n)|从n开始搜索的第一个str的位置| |lastIndexOf(str,n)|从n开始搜索的最后一个str的位置| ==均返回索引值，没有n这个参数的时候默认从0开始== 示例： //找到字符串中所有的'W' var arr = []; var x = box.indexOf('W'); while(x > -1){ arr.push(x); x = box.indexOf('W',x+1); } alert(arr); 大小写转换方法 |方法|描述| |--------|--------| |toLowerCase(str)|将字符串全部被转换为小写| |toUpperCase(str)|将字符串全部被转换为大写| |toLocaleLowerCase(str)|将字符串全部被转换为小写,并且本地化|无区别 |toLocaleUpperCase(str)|将字符串全部被转换为大写，并且本地化|无区别 字符串的模式匹配(四个函数) |方法|描述| |---|---| |String.fromCharCode(asc码)|静态方法，输出asc码对应字符| |localeCompare(str1,str2)|比较两个字符串，并返回相应的值| ？？？？？var box = 'Lee'; box.localeCompare('zoo'); //-1 box.localeCompare('aoo'); //1 1、相等，返回0 2、字符串在字母表中排在字符串参数之前，返回负数，-1 3、之后，返回正数，1 通过JS生成一个HTML标签 var box = '百度'； box.link('www.baidu.com'); //百度 box.bold(); //百度 powered by Gitbook该文件修订时间： 2018-08-31 12:17:23 "},"JS/day13/":{"url":"JS/day13/","title":"内置对象","keywords":"","body":"内置对象：Global和Math. 一、Global对象：不存在，所有在全局作用域定义的变量和函数，都是Global的属性和方法。它有一些内置的属性和方法 1.URI编码方法：对链接进行编码，以便发送给浏览器。采用特殊的UTF-8编码替换所有无效字符，便于浏览器理解 encodeURIComponent(box)编码的更加彻底，故而更常用。 var box = '//W王'; //编码 var a = encodeURI(box); // //W%E7%*E%8B var b = encodeURIComponent(box); // %2F%2FW%E7%8E%8B //解码 alert(decodeURI(a)); alert(decodeURIComponent(a)); 2.eval()方法：字符串解析器的作用，只接收一个参数，就是要执行的JS代码的字符串 eval('var box = 100'); alert(box); eval('function box(){return 123;}'); alert(box); 注意：参数是一个字符串，eval()固然强大，但它具有安全性问题，不慎会导致代码注入。 3.Global对象属性 包含一些属性：undefined、NaN、Object、Array、Function alert(Array); //返回构造函数 4.window对象 Global没办法访问，可以使用window对象来实现全局访问。 alert(window.Array); //同上 二、Math对象 Math.E; //2.718281828459045 Math.PI; //3.141592653589793 Math.min(1,3,4,5,6); //1 Math.max(3,2,8,9,0); //9 Math.ceil(23.4); //24 Math.floor(23.5); //23 Math.round(24.5); //25 Math.random(); //(0,1)之间的随机数 Math.floor(Math.random()*10+1); //1-10之间 //实现固定值之间的随机数 function select(start,end){ var total = end - start +1; return Math.floor(Math.random() * total + start); } select(5,10); //其他方法 Math.abs(-5); //求绝对值 Math.sqrt(9); //求平方根 powered by Gitbook该文件修订时间： 2018-09-01 20:14:25 "},"JS/day14/":{"url":"JS/day14/","title":"面向对象与原型","keywords":"","body":"面向对象与原型 学习要点： 学习条件 创建对象 原型 继承 二、创建对象 工厂模式创建对象解决了创建对象代码重复的问题： function createObject(name,age){ var obj = new Object(); obj.name = name; obj.age = age; obj.run = function(){ return this.name+this.age+'运行中...'; }; return obj; //返回对象的引用 } var box1 = createObject('W',22); var box2 = createObject('W',25); alert(box2.run()); 但instanceof时无法识别他们是哪个对象的实例。 改进：使用构造函数 function Box(name,age){ this.name = name; this.age = age; this.run = function(){ return this.name + this.age + '运行呢...'; }; } var box = new Box('wy',22); alert(box.run()); alert(box instanceof Box); //true 对象冒充调用：但终究不是它的类型 //对象冒充，拿取Box的构造函数 var box1 = new Object(); Box.call(box1,'yy',25); alert(box1.run()); alert(box1 instanceof Box); //false 两个实例化的属性相等，但方法的引用不等 var box1 = new Object('wy',22); var box2 = new Object('wy',22); alert(box1.name == box2.name); //true alert(box1.run() == box2.run()); //true：加括号表示返回的值 alert(box1.run == box2.run); //false ：不加括号表示方法的引用地址 如果想保证引用地址一致，可以将run()方法写在构造函数外面，即全局函数，但是没必要这样做 function run(){ return this.name + this.age + '运行中...'; } 导致新的问题是this在全局下代表window,不代表该对象，且内聚低，零散。 三、原型对象 1.构造函数创建方式 function Box(){ //此处定义实例属性和实例方法 } Box.prototype.name = 'yaoxxx'; Box.prototype.age = 100; Box.prototype.run = function(){ return this.name + this.age + '运行中...'; }; var box1 = new Box(); alert(box1.age); alert(box1.run()); //正常输出 属性和方法的地址都一样 var box1 = new Box(); var box2 = new Box(); alert(box1.age == box2.age); //true alert(box1.run == box2.run); //true —proto—是一个对象，访问不到，通过这个指针指向原型对象 constructor起到连接的作用 判断一个对象实例是否指向原型对象（只要实例化就是自动指向的） Box.prototype.isPrototypeOf(box1); //true 执行流程： 先查找构造函数里的属性和方法，如果有，返回 构造中没有，查找原型，如果有，返回 box1.name = '实例'; //定义实例属性 delete box1.name; //删除实例属性 delete Box.prototype.name; //删除原型属性，不会这么用 判断属性是否在实例中 box1.hasOwnProperty(name); //判断实例中是否存在属性 判断属性在两个中是否存在 'name' in box1; //一个存在为true,均不存在false 判断只有原型中有属性(结合以上) function isProperty(obj,property){ return !obj.hasOwnProperty(property) && property in obj; } 2.字面量创建方式 构造器指向Object function Box(){}; //必须有构造 Box.prototype = { //问题：字面量创建的方式使用constructor属性默认指向Object constructor : Box; //使其强制指向Box name : 'yaoxxx', age : 22 , run : function (){ return this.name + this.age + '运行中...'; } }; var box = new Box(); alert(box.run()); 重写需谨慎（要重写就全部重写） Box.prototype = { //重写其中一个属性 age : 200 //就切断了原来的联系 }; var box = new Box(); box.run(); //报错：not a function 查看某个类是否有某个方法 Array.prototype.sort; //会返回该方法 String.prototype.substring; 为原型添加方法：不推荐，可能导致命名冲突，在代码量少时可以使用 String.prototype.addstring = function(){ return this + '被添加方法...'; }; var box = 'Lee'; alert(box.addstring()); 3.共享是优点也是缺点 function Box(){} Box.prototype = { constructor : Box, name : 'yaoxxx', age : 22, family : ['爸爸','妈妈','妹妹'], run : function(){ return this.name + this.age + '运行中...'; } }; 问题1：共享属性值不可修改 问题2：引用类型值一旦修改所有用原型创建的对象该值都会被修改 故而提出组合构造模式+原型模式：解决了传参和共享 function Box(name,age){ //保持独立部分，不共享 this.name = name; this.age = age; this.family = ['爸爸','妈妈','妹妹']; } Box.prototype = function(){ //保持共享部分 constructor : Box, run : function(){ return this.name + this.age + '运行中...'; } }; 为解决封装性，提出动态原型模式 function Box(name,age){ this.name = name; this.age = age; this.family = ['爸爸','妈妈','妹妹']; Box.prototype.run = function(){ return this.name + this.age + '运行中...'; }; } 问题在于每次调构造new都会执行一次原型 提出判断run的类型来约束它的执行次数 if(typeof run != 'function'){//原型初始化} 如果以上还不能满足：寄生构造模式：工厂模式+构造函数模式 function Box(name,age){ //与工厂模式不同：类名createobj var obj = new Object(); obj.name = name; obj.age = age; obj.run = function (){ return this.name + this.age + '运行中...'; }; return obj; } 稳妥构造函数与寄生构造函数不同点：不能用new var box = Box('你好',22); 四、继承 继承：通过原型链实现 function Box(){ this.name = 'Lee'; } Box.prototype.name = 'Jack'; function Desk(){ this.age = 100; } Desk.Prototype = new Box(); //子类的原型是父类的实例 var desk = new Desk(); alert(desk.name); //就近原则 alert(desk instanceof Object); //子类型从属于它的超类 alert(desk instanceof Desk); alert(desk instanceof Box); powered by Gitbook该文件修订时间： 2018-10-05 11:38:31 "},"JS/day15/":{"url":"JS/day15/","title":"匿名函数与闭包","keywords":"","body":"匿名函数和闭包 1、匿名函数 将匿名函数赋值给变量 var box = function (){return 'yaoxxx';}; //将匿名函数赋值给变量 alert(box()); 自我执行 (匿名函数)(); var box = (function(){alert('Lee');})(); alert((function(){return 'Lee';})()); 传参 (function(arg){alert(arg);})(100); 函数里放函数(闭包) function box(){ return function(){ return 'yaoxxx'; }; } //alert(box()());与以下两条语句功能相同 var b = box(); alert(b()); 2、闭包 优点也是缺点：会将局部变量驻留在内存中，避免使用全局变量。 function box(){ var age = 100; return function(){ age++; return age; } } var b=box(); alert(b()); //101 alert(b()); //102 alert(b()); //103 b = null; //解除引用，等待垃圾回收器回收 循环中匿名函数取值问题 function box(){ var arr = []; for(var i = 0;i this对象的用法：闭包在运行时指向window var User = 'The window'; var box = { user：'The Box', getUser:function(){ //1.var that = this; return function(){ //2.下行改成return that.box; return this.user; } } }; box.getUser(); //返回The window //解决：1.对象冒充(冒充box) alert(box.getUser().call(box)); //1.2处,如代码所示 内存泄漏 IE中匿名函数中引用不能及时销毁，需要手动释放，即赋值为null 模仿块级作用域(比如for,if)：包含自我执行的匿名函数，可以实现私有作用域 function box(){ (function(){ for(var i=0; i 实现全局的私有作用域(封装 )：自动销毁，无需null (function(){ //自我执行 var b = 100; alert(b); })(); 模仿面向对象中的类：1实现私有属性和公共接口 function Box(){ var age = 22; function run(){ return '运行中...'; } this.getAge = function (){ return age + run(); }; } var box = new Box(); box.getAge(); 2.私有变量 fuction Box(value){ var box = value; this.getBox = function(){ return box; }; this.setBox = function(value){ box = value; }; } var box = new Box('WY'); alert(box.getBox()); box.setBox('YY'); alert(box.getBox()); 3.共享变量:匿名函数内部为全局作用域 (function(){ var user = ''; Box = function(value){ user = value; }; Box.prototype.getUser = function(){ return user; }; Box.prototype.setUser = function(value){ user = value; } })(); 单例模式：字面量的声明就是一种单例模式。 powered by Gitbook该文件修订时间： 2018-09-06 13:40:37 "},"JS/day16/":{"url":"JS/day16/","title":"BOM","keywords":"","body":"BOM 一、window对象 它是最顶层的对象，有六大属性，均是对象，document对象下有五大属性。 调用：window.属性 window.方法()，例如：window.alert('yaoxxx')； 二、系统对话框 1、确定和取消 confirm('balabala')；确定和取消分别返回true和false。 2、输入提示框 prompt('请输入一个数字',0)；返回输入的值,0为默认值 print(); 调出打印对话框 find()；调出查找对话框？？？？？？？？？？？ defaultStatus('aaa')；默认初始值 ？？？？？？？ 3、新建窗口 open('http://www.baidu.com','baidu'); 打开一个窗口 open本身返回window对象 var baidu = open('http://www.baidu.com'); 返回子窗口 baidu.alert('Lee'); 表示子窗口弹出 //在子窗口点击父窗口会显示的字 document.onclick = function(){ window.opener.document.write('子窗口让我输出一行字！') }; 4、对窗口的操作 属性 描述 screenLeft 窗口相对于屏幕左边的位置 screenTop 窗口相对于屏幕上边的位置 火狐不支持 screenX 确定窗口的位置 IE不支持 screenY 确定窗口的位置 innerWidth 视口的宽 innerHeight 视口的高 outerWidth 窗口+边框共宽 ouoterHeight 窗口+边框共高 moveTo(100,100) 移动到100，100的位置 moveBy(10,10) 向下及向右移动10,10的位置 resizeTo(300,300) 调整窗口的大小 resizeBy(-10,-10) 以-10的速度缩小 跨浏览器获取窗口位置操作： var leftX = typeof window.screenLeft == 'number' ? window.screenLeft : window.screenX; var topY = typeof window.screenTop == 'number' ? window.screenTop : window.screenY; 跨浏览器(兼容)获取可视窗口： var width = window.innerWidth; var height = window.innerHeight; if(typeof width != 'number'){ if(document.compatMode == 'CSS!Compat'){ width = document.documentElement.clientWidth; height = document.documentElement.clientHeight; }else{ width = document.body.clientWidth; height = document.body.clientHeight; } } 超时调用和间歇调用： setTimeout('代码块'，毫秒数); //不推荐 function box(){...} //不推荐 setTimeout(box，毫秒数); //setTimeout(匿名函数，毫秒数); //扩展性好，封装性好 var box = setTimeout(function(){ alert('WY'); }，毫秒数); //取消超时调用 var box = setTimeout(function(){ //box返回一个ID alert('WY'); }，毫秒数); clearTimeout(box); //间歇调用,重复不断地执行 var box = setInterval(function(){ alert('WY'); },1000) clearInterval(box); //使用超时调用，模拟定时 var num = 0; var max = 5; function box(){ num++; if(num == max){ alert('5秒到了'); }else{ setTimeout(box,1000); //递归调用 } } setTimeout(box,1000); location对象 //返回当前URL window.location; window.document.location; location对象 描述 location.hash = '#1' 设置#后的字符串，并跳转 location.port = 8888 设置端口号，并跳转 location.hostname = 'WY' 设置主机名，并跳转 location.search = '？id=5' 不停跳转 location.href = 'http://www.baidu.com' 设置跳转的URL 常用 location.assign('http://www.baidu.com') 跳转到指定的URL location.reload() 有效的重新加载 location.reload(true) 从源头加载 location.replace('http://www.baidu.com') 不产生任何历史记录的跳转 //获取URL参数 ?id=9&search=error function getArgs(){ var qs = location.search.length > 0 ? location.search.substring(1) : 'null'; var items = qs.split('&'); var item = []; var args = []; var name,value; for(var i = 0; i history对象 保存用户上网记录 history方法 描述1 history.back(); 回到前一条记录 history.forward(); 下一条记录 go(num); 1下一 -1上一 prev next go2 function back(){ history.back(); } powered by Gitbook该文件修订时间： 2018-09-10 12:16:09 "},"JS/day17/":{"url":"JS/day17/","title":"浏览器检测","keywords":"","body":"浏览器检测 navigator对象 1、能力检测 powered by Gitbook该文件修订时间： 2018-09-10 16:16:00 "},"JS/day18/":{"url":"JS/day18/","title":"DOM基础","keywords":"","body":"DOM 1、介绍 有三个等级：DOM1 、 DOM2、 DOM3 IE中的DOM对象都是以COM对象的形式实现的，故IE的DOM会和其他浏览器有差异 2、查找元素 元素节点方法 | 方法 | 描述 | | ---------------------------- | -------------------------------------------- | | getElementById('id') | 通过ID,j建议区分大小写 HTMLDivElement | | getElementsByTagName('li') | 参数传递标签名，返回一个数组集合 | | getElementsByName('li') | 通过name获取，返回一个数组集合，注意是否合法 | | getAttribute('id') | 获取元素中某个属性的值 | | setAttribute('属性名'，‘值’) | 设置元素中某个属性和值 | | removeAttribute() | 移除元素节点中某个属性 | input中有合法的name属性，div没有 获得元素属性 属性 描述 box.tagName 获取这个元素节点的标签名 box.innerHTML 获取和赋值这个元素节点的纯文本内容，包含HTML标签 box.id 获取这个元素节点的id属性的值，不是属性节点 box.title 获取这个元素节点的title属性的值 box.style 获取style属性对象 box.style.color 获取style属性中color属性的值 box.className 获取class属性的值 自定义属性只有IE可以获取到 要么做兼容，要么不使用 注意： onload事件，预加载后执行（所有网页的内容都加载完毕后，再执行的代码） window.onload= function(){ var str = document.getElementByid（'id'）; } 3、DOM节点 节点分为元素节点、属性节点、文本节点。 1、节点属性： 元素.nodeType； //1.元素节点 2.属性节点 3. 文本节点 元素.nodeName； //输出元素名称，属性名称，#text 元素.nodeValue； //元素节点输出null，属性节点输出属性值，文本节点输出文本内容（不包含html） 2、层次节点属性 层次结构划分为：父节点与子节点、兄弟节点两种 childNodes ： 获得当前元素节点所有子节点，返回一个数组 firstChild ：获得当前元素节点第一个子节点 lastChild ：获得当前元素节点最后一个子节点 ownerDocument：获得该节点的文档根节点，相当于document parentNode：获得当前节点的父节点 previousSibling：获得当前节点同级的前一个节点 nextSibling：获得当前节点同级的后一个节点 attributes[]：获得当前元素节点的所有属性节点集合 示例 测试DIV测试EM结尾 //前后两个文本节点，中间是元素节点 注意：innerHTML和nodeValue的区别： 获取：文本节点无法使用innerHTML标签输出文本内容 赋值：innerHTML：输出文本内容，可以包括标签 ​ nodeValue：会将标签输出 示例：忽略空白文本节点：直接删除空位文本节点即可 function filterSpaceNode(nodes){ for(var i=0;i 4、节点操作：创建、复制、插入、删除、替换节点 document.write('这是一个段落！')；将任意字符串插入到文档 createElement('p')；创建一个元素节点 appendChild()；将一个新节点添加到某个子节点的末尾上 createTextNode()；创建一个文本节点 insertBefore(p,box)；把节点插入到指定节点的前面 replaceChild(p,box)；把节点替换成指定的节点,div换成了p cloneNode(true)；把子节点复制出来，true表示复制内容，false表示只复制标签 removeChild()；删除指定节点 powered by Gitbook该文件修订时间： 2018-09-12 12:36:50 "},"JS/day19/":{"url":"JS/day19/","title":"DOM进阶","keywords":"","body":"DOM进阶 一、DOM类型 1、Node类型 node.ELEMENT_NODE //元素节点类型值 2、document类型 document类型表示文档，或文档的根节点，隐藏，无具体的元素标签 document.documentElement; //HTMLHtmlElement document.body; //HTMLBodyElement document.doctype; //DocumentType document.childNode[0].nodeName; //Comment 属性： document.title //获取和设置title标签的值 document.URL //获取URL路径 document.domin //获取域名，服务器端 document.referrer //获取上一个URL，服务器端 对象： document.form //获取文档中表单元素集合 3、Element类型 元素对应类型表： 4、Text类型 box.normalize(); //合并box下两个相邻的文本节点 box.firstChild.splitText(3) //分离一个节点 5、Comment类型 nodeType：8；nodeName：#comment；nodeValue：注释的内容 二、DOM扩展 1、呈现模式 标准模式：document.compatMode == 'CSS1Compat' 混杂模式：document.compatMode == 'BackCompat' 2、滚动 document.getElementById('box').scrollIntoView() //设置指定可见 3、children属性 box.children.length; //得到子节点数目 4、contains方法 判断一个节点是否是另一个节点的后代 三、DOM操作内容 1、innerText属性 获取文本内容及设置文本，会过滤掉html 相似属性：textContent 2、innerHTML 不拒绝HTML，可获取可解析 3、outerText 赋值时会将元素直接抹去,不推荐 4、outerHTML 同上，不推荐 powered by Gitbook该文件修订时间： 2018-09-12 23:17:20 "},"JS/day20/":{"url":"JS/day20/","title":"DOM操作表格及样式","keywords":"","body":"通过DOM操作表格及样式 要点： 操作表格 操作样式 一、操作表格 一些属性和方法： //操作表格 window.onload = function(){ var table = document.getElementByTagName('table')[0]; table.caption.innerHTML; //获取caption table.tHead; table.tBodies; table.rows.length; table.tBodies[0].rows.length; //表体的行数 table.tBodies[0].rows[0].cells.length; //第一行的单元格数目 table.tBodies[0].rows[1].cells[1].innerHTML; //第二行第二个单元格内容 table.deleteCaption(); //删除标题 table.deleteTHead(); //删除头 table.tBodies[0].deleteRow(0); //删除行 table.tBodies[0].rows[0].deleteCell(0); //删除单元格 } //创建表格 window.onload = function(){ var table = document.createElement('table'); table.border = 1; table.width = 300; var caption = document.createElement('caption'); table.appendChild(caption); caption.innerHTML = '人员表'; var thead = document.createElement('thead'); table.appendChild(thead); var tr = document.createElement('tr'); thead.appendChild(tr); var th = document.createElement('th'); tr.appendChild(th); //th.innerHTML = 'one'; var thtext = document.createTextNode('Text'); th.appendChild(thtext); document.body.appendChild(table); } 二、操作样式 检测浏览器是否支持DOM1级CSS能力或DOM2级CSS能力 document.implementation.hasFeature('CSS','2.0'); //支持就返回true document.implementation.hasFeature('CSS2','2.0'); document.implementation.hasFeature('HTML','2.0');*/ 1、style属性访问元素样式（优点：可赋值可取值，缺点：只能获取行内样式） 行内 、内联style标签 、链接link //获取box元素 var div = document.getElementById('con'); //可赋值可取值 alert(div.style.float); //right alert(div.style.backgroundColor); //red //修改有效 div.style.float = 'left'; //删除和添加属性 div.style.removeProperty('backgroundColor'); div.style.setProperty('color','blue'); 2、计算样式访问（优点：可以获取所有样式 缺点：不能赋值只能获取） //(不管在哪里设置CSS,都会驻留在浏览器内存中，故都可以获取到)，但不能赋值 var div = document.getElementById('con'); //null表示无伪类（:hover） var style = window.getComputedStyle(div,null); alert(style.float); //border属性获取不到，被计算后不存在，属于复合性属性 总结：三种操作CSS的方法： style行内，可读可写； 使用getComputedStyle或currentStyle，可读不可写； cssRules或rules，内联和链接，可读可写 3、 查看是否支持DOM2级样式表 document.implementation.hasFeature('StyleSheets','2.0'); 获取样式元素： document.getElementsByTagName('link')[0]; //HTMLLinkElement document.getElementsByTagName('style')[0]; //HTMLStyleElement 属性和方法： 属性和方法 说明 disabled 获取和设置样式表是否被禁用 href 通过link包含的，则获取URL，否则为null media 样式表支持的所有媒体类型的集合 ownerNode 指向拥有当前样式表节点的指针 parentStyleSheet @import导入的情况下，得到父CSS对象 title ownerNode中title属性的值 type 样式表类型字符串 cssRules 样式表包含样式规则的集合 deleteRule(index) 删除cssRules集合中指定位置的规则 insertRule(rule,index) 向cssRules集合中插入rule字符串 var link = document.getElementsByTagName('link')[0]; //HTMLLinkElement //法1得到CSSStyleSheet(主要) var sheet = link.sheet || link.style.sheet; //得到CSSStyleSheet sheet.disabled; //false ,可设置为true sheet.href; //CSS文件位置的URL file://D:work/gitalab/js/day../bom.css sheet.media; //MediaList,集合 Object MediaList sheet.title; //得到title属性的值 标签中的属性 sheet.deleteRule(0); //删除第一个样式规则（id或class选择器） sheet.insertRule('body{background-color:red}',0); //在第一个位置添加一个样式规则 //法2得到CSSStyleSheet var sheet = document.styleSheets[0]; var rules = sheet.cssRules || sheet.rules ; var rule = rules[0]; alert(rule.cssText); powered by Gitbook该文件修订时间： 2018-09-15 10:18:52 "},"JS/day21/":{"url":"JS/day21/","title":"DOM元素尺寸和位置","keywords":"","body":"DOM元素尺寸和位置 学习要点： 获取元素CSS大小 获取元素实际大小 获取元素周边大小 1、获取元素CSS大小 1、通过style内联获取元素大小 var box = document.getElementById('box'); box.style.width; box.style.height; 2、通过计算获取元素大小 var style = window.getComputedStyle ? window.getComputedStyle(box,null) : null || box.currentStyle; style.width; style.height; 3、通过CSSStyleSheet对象中的cssRules属性获取元素大小(只能获取内联和链接，不能获取行内和计算后的样式) var sheet = document.styleSheet[0]; //获取link或者style var rule = (sheet.cssRules || sheet.rules)[0]; rule.style.width; rule.style.height; 总结：以上方法只能获取元素的CSS大小（某属性的值）均不能获取元素实际大小 2、获取元素实际大小 1、clientWidth和clientHeight 可以获取元素可视区的大小，可以得到元素内容及内边距所占据的大小 box.clientWidth; //200（默认是px单位） box.clientHeight; 举个栗子： 1、增加边框 ，无变化 2、增加外边距 ，无变化 3、增加内边距 ，最终值为原本大小加上内边距的大小 4、增加滚动条 ，最终值等于原本大小减去滚动条的大小 2、scrollWidth和scollHeight //200 获取滚动内容的元素大小 3、offsetWidth和offsetHeight（兼容：比较好用） 可以返回实际大小，包含边框、内边距和滚动条 举个栗子： 1、增加边框，最终值加上边框大小 2、增加内边距，最终值加上内边距大小 3、增加外边距，无变化 4、增加滚动条，无变化，不会减小 PS：对于元素大小的获取，一般是块级并且设置了CSS大小的元素较为方便，如果是内联或者没有设置大小的元素就尤为麻烦，建议使用时注意。 3、获取元素周边大小 1、clientLeft和clientTop（border） 可以获取设置了左边框和上边框宽度，不提供Right和Bottom 2、offsetLeft和offsetTop 可以获取当前元素相对于父元素的位置（父元素设置成position:absolute） box.offsetLeft; //border之间的距离 box.offsetTop; 3、scrollTop和scrollLeft 可以获取滚动条被隐藏的区域大小（是指拖到某个位置的高度） box.scrollTop; //获取滚动内容上方的位置 box.scrollLeft; //获取滚动内容左方的位置 让滚动条回到起始位置： function ScrollStart(element){ if(element.scrollTop != 0) element.scrollTop = 0; } powered by Gitbook该文件修订时间： 2018-09-15 14:48:44 "},"JS/day22/":{"url":"JS/day22/","title":"动态加载脚本和样式","keywords":"","body":"动态加载脚本和样式 学习要点： 元素位置 动态脚本 动态样式 1、元素位置 补充方 法：getBoundingClientRect()，返回一个矩形对象，包含四个属性，left、top、right、bottom。分别表示元素各边和页面上边和左边的距离。 var box = document.getElementById('box'); //元素上边距离页面上边的距离 box.getBouondingClientRect().top; //元素右边距离页面上边的距离 box.getBoundingClientRect().right; //元素左边距离页面左边的距离 box.getBoundignClientRect().left; //元素下边距离页面左 边的距离 box.getBoundingClientRect().bottom; 存在兼容性问题： 2、动态脚本 在适时的时候加载相应的脚本（js文件）： //加载某个js文件 var flag = true; if(flag){ loadScript('somejs.js'); //设置标志位操作DOM去执行代码 } function loadScript(url){ var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; document.getElementsByTagName('head')[0].appendChild(script); } 加载相应的js代码： var script = document.createElement('script'); script.type = 'text/javascript'; //IE不兼容 改为script.text = \"alert(\"yaoxxx\")\"; var text = document.createTextNode('alert(\"yaoxxx\")'); script.appendChild(text); docuement.getElementsByTagName('head')[0].appendChild(script); 3、动态样式（style标签和link标签） //动态执行link var flag = true; if(flag){ loadStyle('style.css'); } function loadStyle(url){ var link = document.createElement('link'); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = url; document.getElementsByTagName('head')[0].appendChild(link); } //动态执行style var flag = true; if(flag){ var style = document.createElement('style'); style.type = 'text/css'; //var box = document.createTextNode('#box{background-color:red}'); //style.appendChild(box); IE不支持，故用下面的写法 docuemnt.getElementsByTagName('head')[0].appendChild(style); insertRule(document.styleSheet[0],'#box','background-color:red',0); } function insertRule(sheet,selectorText,cssText,position){ //如果不是IE if(sheet.insertRule){ sheet.insertRule(selectorText + '{'+cssText+'}',position); }//如果是IE else if(sheet.addRule){ sheet.addRule(selectorText,cssText,position); } } powered by Gitbook该文件修订时间： 2018-09-15 21:17:55 "},"JS/day23/":{"url":"JS/day23/","title":"事件入门","keywords":"","body":"事件入门 学习要点： 事件介绍 内联模型 脚本模型 事件处理函数 1、事件介绍 Javascript有三种事件模型：内联模型、脚本模型和DOM2模型。 2、内联模型 不与HTML分离的市价能处理函数 3、脚本模型 为解决内联，在js脚本中处理事件，这样的方式称为脚本模型 var input = document.getElementsByTagName('input')[0]; //通过匿名函数可以直接触发相应的代码 input.onclick = function (){ alert('Lee'); }; //也可以将函数名赋给事件 input.onclick = box; 4、事件处理函数 事件类型分为：鼠标事件、键盘事件和HTML事件。 鼠标事件： onclick：点击鼠标按钮或按下回车键时触发 ondbclick：双击主鼠标按钮时触发 onmousedown：按下鼠标还未弹起时触发 onmouseup：释放鼠标按钮时触发 onmouseover：鼠标移到你某个元素上方时触发 onmouseout：移出某个元素上方时触发 onmousemove：在元素上移动时触发 键盘事件： onkeydown：按下键盘任意键触发 onkeypress：按下键盘上的字符键触发，如果按住不放，会重复触发 onkeyup：释放键盘上的键触发 HTML事件： window.onload：当页面完全加载后在window上面触发，或当框架加载完毕后在框架集上触发 window.onunload：当页面完全卸载后在window上面触发，或当框架集卸载后在框架集上触发 select：当用户选择文本框（input或textarea）中的一个或多个字符触发 change：当文本框（input或textarea）内容改变且失去焦点后触发 focus：当页面或者元素获得焦点时在window及相关元素上面触发 blur：当页面或元素失去焦点时在window及相关元素上触发 submit：点击提交按钮在form元素上触发 reset：点击重置按钮在form元素上触发 resize：当窗口或框架的大小变化时在window或框架上触发 scroll：当用户滚动带滚动条的元素时触发 powered by Gitbook该文件修订时间： 2018-09-15 22:17:19 "},"JS/day24/":{"url":"JS/day24/","title":"事件对象","keywords":"","body":"事件对象 学习要点： 事件对象 鼠标事件 键盘事件 W3C与IE 1、事件对象 事件处理分三部分组成：对象.事件处理函数 = 函数 事件对象，一般称为event对象，是浏览器通过函数把这个对象作为参数传递过来的。 var input = document.getElementsByTagName('input')[0]; input.onclick = function(evt){ alert(evt); //MouseEvent,鼠标事件对象 } IE存在兼容性问题： window.onload = function(){ document.onmouseup = function(evt){ var e = evt || window.event; //W3C || IE alert(e.button); } } 2、鼠标事件 鼠标按钮 在它的event中存在一个button属性，表示按下或释放按钮。通过event.button获取 *非IE中的button属性 值 说明 0 表示主鼠标按钮（鼠标左键） 1 中间的鼠标按钮（鼠标滚轮按钮） 2 次鼠标按钮（鼠标右键） *IE中的button属性 存在兼容性问题，switch 语句可解决 function getButton(evt){ var e = evt || window.event; //判断顺序先W3C再IE,因为谷歌都支持 if(evt){ //W3C return e.button; }else if(window.event){ //IE switch(e.button){ case 1: return 0; case 4: return 1; case 2: return 2; } } } //调用 document.onmouseup = function(evt){ if(getButton(evt) == 0) alert('按下了左键'); if(getButton(evt) == 1) alert('按下了中键'); if(getButton(evt) == 2) alert('按下了右键'); }; 可视区及屏幕坐标 事件对象提供了两组获取浏览器坐标的属性。可视区左边和屏幕坐标。 属性 说明 clientX 可视区X坐标 clientY 可视区Y坐标 screenX 屏幕区X坐标 screenY 屏幕区Y坐标 document.onclick(event){ var e = event || window.event; alert(e.screenX + ',' +e.screenY); //距离屏幕 alert(e.clientX +',' +e.clientY); //距离可视区 } 修改键 有时需要某些键来配合鼠标来触发一些特殊的事件。Shift、Ctrl、Alt、Win。经常被用来修改鼠标事件和行为。 修改键属性 属性 说明 shiftKey 判断是否按下了Shift键 ctrlKey 判断是否按下了ctrlKey键 altKey 判断是否按下了alt键 metaKey 判断是否按下了windows键，IE不支持 function getKey(evt){ var e = evt || window.event; var keys = []; if(e.shiftKey) //为数组添加元素 keys.push('shift'); if(e.ctrlKey) keys.push('ctrl'); if(e.altKey) keys.push('alt'); return keys; } //调用 document.onclick = function(evt){ alert(getKey(evt)); }; 3、键盘事件 keydown : 按下任意键，按下立即触发 keyup : 弹起任意键，按下然后释放触发 keypress：按下字符键，abc,123,特殊字符之类的，不包括shift、ctrl等 键码：键盘上的任意键，返回的是ASC码的小写字母对应的值，在字符上和字符编码的asc码是一致的。 window.onload = function (){ document.onkeydown = function(evt){ var e = evt || window.event; alert(e.keyCode); } } charCode在使用keypress的情况下，会返回字符键盘的ASC编码。 window.onload = function (){ document.onkeypress = function(evt){ var e = evt || window.event; alert(e.charCode); } } 需要做兼容，不同浏览器不同。 4、W3C和IE 事件流，当几个具有时间的元素重叠在一起的时候，在点击的时候，在点击范围内的所有元素都会触发事件。 事件流包括两种模式：冒泡和捕获。 会优先触发到最内层的事件： document.onclick = function(){ alert('document'); }; document.documentElement.onclick = function(){ alert('HTML'); }; document.body.onclick = function(){ alert('body'); }; document.getElementById('box').onclick = function(){ alert('div'); }; document.getElementsByTagName('input')[0].onclick = function(){ alert('input'); }; 阻止冒泡的方式： function stopBubble(evt){ var e = evt || window.event; window.event?e.cancelBubble = true : e.stopPropagtion(); //IE与W3C不同 } powered by Gitbook该文件修订时间： 2018-09-18 13:32:43 "},"JS/day25/":{"url":"JS/day25/","title":"事件绑定及深入","keywords":"","body":"事件绑定及深入 学习要点： 传统事件绑定的问题 W3C事件处理函数 IE事件处理函数 事件对象的其他补充 1、传统事件绑定的问题 问题一：覆盖：一个事件处理触发两次事件时，后面的会把前面的覆盖 解决： window.onload = function(){ alert('执行本事件'); }; if(typeof window.onload == 'function'){ //判断之前是否有window.onload var saved = null; //一个保存器 saved = window.onload; //保存之前的window.onload } window.onclick = function(){ if(saved) saved(); //saved()相当于window.onload = function(){///} alert('执行本事件'); }; 问题二：事件切换器 2、W3C事件处理函数 所有DOM节点都包含的两个方法：添加事件和删除事件的操作：addEventListener()和removeEventListener()。并且都接收三个参数：事件名、函数、冒泡或捕获的布尔值（true：捕获，false：冒泡） window.addEventListener('load',function(){alert('添加事件监听器')},false); 优点：1、不需要自己定义了； 2、可以屏蔽相同的函数； ​ 3、可以设置冒泡和捕获。（true和false） .red{ width: 100px; height: 100px; background-color: red; } .blue{ width: 100px; height: 100px; background-color: blue; } DIV window.addEventListener('load',function (){ var box = document.getElementById('box'); box.addEventListener('click',function(){ alert('切换之前...'); },false); box.addEventListener('click',toblue,false); },false); function toblue() { //alert(this); //HTMLDIVElement this.className='blue'; this.removeEventListener('click',toblue,false); this.addEventListener('click',tored,false); } function tored() { this.className='red'; this.removeEventListener('click',tored,false); this.addEventListener('click',toblue,false); } 3、IE事件处理函数（不常用） IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()，都接收相同的参数：事件名称和函数。 区别： IE不支持捕获，只支持冒泡 不能屏蔽重复的函数 IE中的this指向window而不是DOM对象 在传统事件上，IE无法接收event对象，但用了attachEvent却可以。 注意：这两个方法只能运行在IE低版本上，不常用，淘汰。 window.attachEvent('onload',function(){ alert('加载之前、、、'); var box=document.getElementById('box'); box.attachEvent('onclick',toblue); }); function toblue(){ var that = window.event.srcElement; that.className='blue'; that.detachEvent('onclick',toblue); that.attachEvent('onclick',tored); } function tored(){ var that = window.event.srcElement; that.className = 'red'; that.detachEvent('onclick',tored); that.attachEvent('onclick',toblue); } 存在兼容W3C和IE的问题： 4、事件对象的其他补充 1、relatedTarget：W3C的这个属性可以在mouseover和mouseout事件中获取从哪里移入和从哪里移出的DOM对象，对应IE的fromElement 和 toElement evt.relatedTarget; 2、阻止默认行为：比如屏蔽一个链接的跳转行为 //法1：W3C:preventDefault link.onclick = function(evt){ evt.preventDefault(); } //法2：IE:returnValue的值为false link.onclick = function(){ window.event.returnValue=false; } 兼容W3C和IE： function preDef(evt){ var e = evt || window.event; if(e.preventDefault){ e.preventDefault(); }else{ e.returnValue=false; } } 3、卸载事件beforeunload,可以在离开本页的时候给出相应的提示 window.addEvent(window,'beforeunload',function(evt){ preDef(evt); }); 4、鼠标滚轮mousewheel和DOMMouseScoll，用于获取鼠标上下滚轮的距离 powered by Gitbook该文件修订时间： 2018-09-18 22:02:10 "},"JS/day26/":{"url":"JS/day26/","title":"表单处理","keywords":"","body":"表单处理 学习要点： 表单介绍 文本框脚本 选择框脚本 一、表单介绍 1、得到一个表单： 通过id和标签名得到表单对象 2、阻止表单提交： addEvent(fm,'submit',function(evt){ var e = evt || window.event; if(e.preventDefault) e.preventDefault(); else e.returnValue = false; }); 3、自定义表单提交事件（使非submit按钮提交表单） //span.click document.keydown = function(evt){ var e = evt || window.event; if(e.ctrlKey && e.keyCode == 13) //判断按住了ctrl和enter键，就触发 fm.submit(); } 4、避免表单中命名含有submit等敏感字符 5、避免重复提交 在第一次提交之后将按钮禁用，并设置flag标志已经提交过一次了 6、重置按钮 用法和submit相同，作用是将表单内容清空。 7、表单控件 input submit textarea select 8、表单字段的访问 fm.elements[0]； //获取第一个表单字段元素 fm.elements['user']； //通过name获取表单元素，可能是一个节点列表 9、共有的表单字段属性 fm.elements[0].name ； //得到name属性 fm.elements[0].disabled == true ； //得到禁用属性并设置为禁用 不推荐使用type属性修改元素的类型 10、共有的表单字段方法 11、共有的表单字段事件 二、文本框脚本 类型：多行文本框 1、获取文本的值 value：内容写在标签之间，HTML中没有value属性，JS中value属性用于获取标签之间 defaultValue：获取在HTML标签中设置的初值 2、选定文本的值 select：选定文本 setSelectionRange(0,1)：选定部分文本，第0个位置到第一个位置 IE存在兼容性问题： select事件，选定文本就触发，传this并通过this.value获取全部文本。 3、取得选择的文本 //IE不支持 addEvent(textFiele,'select',function(){ ​ alert(this.value.substring(this.selectionStart，this.selectionEnd))； }) //IE document.selection.createRange().text； 选择框脚本 通过select和option元素创建 北京 上海 广州 window.onload = function () { var fm = document.getElementsByTagName('form')[0]; var city = fm.elements[0]; //属性 也可以在HTML标签中设置 multiple=\"multiple\" 和 size=\"3\" // city.multiple=true; 支持多选 // city.size=2; 显示的行数 //标准DOM获取属性的值：不推荐 /* alert(city.options[0].firstChild.nodeValue); alert(city.options[0].getAttribute('value')); //HTML DOM兼容性很好，推荐 alert(city.options[0].value); alert(city.options[0].text);*/ // 该属性属于select对象 // city.selectedIndex=2; //该属性属于option对象 //city.options[2].selected = true; //添加一个option：三种方法 var option = document.createElement('option'); //法一： var text = document.createTextNode('深圳'); option.setAttribute('value','深圳v'); //法二： //option.value = '深圳v'; //option.text = '深圳'; option.appendChild(text); city.appendChild(option); //法三：构造函数，并能指定位置 var opt = new Option('北京t','北京v'); city.add(opt,3); //移除：两种方法 //city.removeChild(city.options[0]); //city.remove(0); } powered by Gitbook该文件修订时间： 2018-09-22 13:07:49 "},"JS/day27/":{"url":"JS/day27/","title":"错误处理与调试","keywords":"","body":"错误处理与调试 学习要点： 浏览器错误报告 错误处理 错误事件 错误处理策略 调试技术 调试工具 1、浏览器错误报告 各大浏览器中错误调试工具在什么位置： 火狐-->工具-->控制台......... 2、如何处理错误事件 /* * try-catch特点： * 1、捕获错误信息 * 2、避免浏览器控制台报错 * 3、屏蔽错误，继续向下执行，若和下面的代码有关联就会继续出错 */ try{ window.asdfsd(); }catch(e){ //接收错误对象 //alert(e); //打印错误对象 此处打印：TypeError:window.asdfsd is not a function alert(e.name); //Typeerror alert(e.message);//window.asdfsd is not a function（推荐使用的属性） }finally{ alert('必须被执行的部分'); } 3、错误类型 基类Error，其他六种继承于它 new Array(-3); //RangeError:invalid array length 无效的数组长度 var box = a ; //ReferenceError:a is not defined 未定义的变量 a$b; //SyntaxError: missing ; before statement 语法错误 new 10; //TypeError: 10 is not a constructor eval(abc); //不常见：evalError 表示全局函数eval()的使用方式与定义的不同时抛出 //URIError:不常见 通过判断类型自定义错误信息： try{ new 10; }catch (e) { if(e instanceof TypeError){ alert('类型错误！'); }else{ alert('未知错误！'); } } 4、错误处理策略 1 > 慎用try-catch语句（耗费系统资源）： 可以通过修改代码来排错的，不需要用try-catch 浏览器兼容性问题，可以通过if语句判断的不用它 无法修改代码 的情况下，用try-catch比较有意义 2 > 抛出错误：当我们无法解决的情况下，就需要把错误报出： throw new (...)Error(\"这里是错误信息！\"); try{ new 10; }catch(e){ if(e instanceof TypeError) throw new TypeError('类型错误！new的时候，可能产生了错误！'); } new 10; // 浏览器自己会抛出错误 5、调试技术 通过alert() 控制台： console.error('错误'); console.info('信息'); console.log('日志'); console.warn('警告'); 设置断点并执行 单步进入：一步一步执行流程 单步跳过：跳到下一个函数快 单步退出：跳出执行到内部的函数 断续：继续执行代码 重新运行：重新单步调试 监控： 监控变量的变化 也可以新建监控表达式来查看自己关心的变量 powered by Gitbook该文件修订时间： 2018-09-22 18:40:14 "},"JS/day28/":{"url":"JS/day28/","title":"cookie与存储","keywords":"","body":"Cookie与存储 学习要点： cookie cookie局限性 其他存储 它的意图：在本地的客户端的磁盘上以很小的文件形式保存数据。 一、cookie alert(document.cookie); //i18next=zh_CN //向本地磁盘写入cookie document.cookie='user=王XX'; //本地不存在域名，所以域就为空 alert(document.cookie); //显示user=王XX //加密cookie document.cookie = 'user='+encodeURIComponent('王XX'); //解密输出 alert(decodeURIComponent(document.cookie)); cookie的生命周期不设置默认是会话结束，那么如何设置呢？ var date = new Date(); date.setDate(date.getDate()+7); alert(date); //设置过期时间 document.cookie = 'user='+encodeURIComponent('王XX')+';expiress='+date; 删除cookie： 将当前时间调到cookie生命周期的后面 document.cookie = 'user='+encodeURIComponent('王XX')+';expiress='+new Date(0); domain 用于限制只有设置的域名才可以访问，没有设置会默认限制为创建 cookie 的域名。 var domain = 'yc60.com'; document.cookie = \"user= \" + encodeURIComponent('王XX') + \";domain=\" + domain; secure 指定必须通过https来通信访问：仅限加密连接，安全性更好 document.cookie = 'user='+encodeURIComponent('王XX')+';secure'; 创建cookie function setCookie(name, value, expires, path, domain, secure) { var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); if (expires instanceof Date) { cookieText += '; expires=' + expires; } if (path) { cookieText += '; expires=' + expires; } if (domain) { cookieText += '; domain=' + domain; } if (secure) { cookieText += '; secure'; } document.cookie = cookieText; } 获取cookie function getCookie(name) { var cookieName = encodeURIComponent(name) + '='; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart > -1) { var cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) { cookieEnd = document.cookie.length; } cookieValue = decodeURIComponent( document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); } return cookieValue; } 删除cookie function unsetCookie(name) { document.cookie = name + \"= ; expires=\" + new Date(0); } 失效天数 function setCookieDate(day) { if (typeof day == 'number' && day > 0) { var date = new Date(); date.setDate(date.getDate() + day); } else { throw new Error('传递的 day 必须是一个天数，必须比 0 大'); } return date; } 二、cookie的局限性 1、每个特定域名下最多生成20个cookie，不同浏览器之间有所区别。 2、cookie最大大约4096字节（4k）,为保证兼容性，一般不超过4095字节 3、存储在客户端的文件，重要且敏感的数据不建议保存在cookie中，可能会被截获，不安全 三、其他存储 IE存储： Web存储： sessionStorage 、localStorage 、globalStorage三种Web存储方式 localStorage已经取代globalStorage //通过方法存储和获取 sessionStorage.setItem('name','yaoxxx'); alert(sessionStorage.getItem('name')); //通过属性存储和获取 sessionStorage.newitem = 'yao'; alert(sessionStorage.newitem); //yaoxxx 关闭浏览器再打开为null //删除三种（清缓存、关闭浏览器、remove方法） sessionStorage.removeItem('name'); 总结：这三个对象都是永久保存的，只有手工清理或者清除浏览器缓存方可失效。 ​ 容量会根据浏览器不同而不同。 powered by Gitbook该文件修订时间： 2018-09-22 21:22:31 "},"JS/day29/":{"url":"JS/day29/","title":"XML","keywords":"","body":"XML 学习要点： IE中的XML DOM2中的XML 跨浏览器处理XML 一个微型的结构化的数据库，保存一些小型数据用的 一、IE中的XML window.onload = function () { //载入XML文件的两种方式：1、加载XML字符loadXML();2。加载XML外部文件load() //由于XML和XHTML一样，都是通过DOM节点操作的，所以之前的知识都可以用得上 var xmlDom = createXMLDOM(); xmlDom.loadXML('\\nyaoxxx\\n'); //序列化xml字符串 alert(xmlDom.xml); } 同步和异步： 同步：加载XML完成之前，代码不会继续执行，直到完全加载了XML再返回。 xmlDom.async = false; 异步：加载XML时，JS会把任务丢给浏览器内部后台去处理，不会造成堵塞，但要配合readystatechange事件使用，通常我们都采用异步 xmlDom.async = true; //默认使用异步加载 xml中readystatechange事件 就绪状态（.readyState属性） 说明 1 DOM正在加载 2 DOM已经加载完数据 3 DOM已经可以使用，但某些部分还无法访问 4 DOM已经完全可以 PS:readyState可以获取就绪状态值 存在问题：服务器使用的是异步加载，但未加载完就序列化得不到字符串，解决办法： var xmlDom = createXMLDOM(); xmlDom.asyc = true; //这个事件必须放在load前面，意图先载入事件 xmlDom.onreadystatechange = function(){ //有4种状态,故会输出4次 alert(xmlDom); //输出1次 if（xmlDom.readyState == 4）{ if(xmlDom.parseError.errCode == 0){ alert(xmlDom.xml); }else{ throw new Error('错误行号：'+xmlDom.parseError.line+'\\n错误代号:'+xmlDom.parseError.errCode+'错误解释:'+xmlDom.parseError.reason) } } } //真正加载，激活它 xmlDom.load('demo.xml'); 打印错误 示例如上： 二、DOM2中的XML 1、创建 2、载入 DOM2 只支持 load()方法，载入一个同一台服务器的外部 XML 文件。当然，DOM2 也 有 async 属性，来表面同步或异步，默认异步。 //同步情况下 var xmlDom = document.implementation.createDocument('','root',null); xmlDom.async = false; xmlDom.load('test.xml'); alert(xmlDom.getElementsByTagName('user')[0].tagName); //异步情况下 var xmlDom = document.implementation.createDocument('','root',null); xmlDom.async = true; addEvent(xmlDom, 'load', function () { //异步直接用onload 即可 alert(this.getElementsByTagName('user')[0].tagName); }); xmlDom.load('test.xml'); 3、没有loadXML方法直接解析XML字符串 var xmlParser = new DOMParser(); //创建 DOMParser 对象 var xmlStr = 'Lee'; //XML 字符串 var xmlDom = xmlParser.parseFromString(xmlStr, 'text/xml'); //创建 XML DOM 对象 alert(xmlDom.getElementsByTagName('user')[0].tagName); //获取 user 元素标签名 4、没有序列化XML的属性，所以提供了 XMLSerializer 类型来帮助序列化 XML 字符串。 var serializer = new XMLSerializer(); //创建 XMLSerializer 对象 var xml = serializer.serializeToString(xmlDom); //序列化 XML alert(xml); 5、解析错误 在 DOM2 级处理 XML 发生错误时，并没有提供特有的对象来捕获错误，而是直接生 成另一个错误的 XML 文档，通过这个文档可以获取错误信息。 var errors = xmlDom.getElementsByTagName('parsererror'); if (errors.length > 0) { throw new Error('XML 格式有误：' + errors[0].textContent); } powered by Gitbook该文件修订时间： 2018-09-25 21:03:36 "},"JS/day30/":{"url":"JS/day30/","title":"XPath","keywords":"","body":"XPath 学习要点： IE中的XPath W3C中的XPath XPath跨浏览器兼容 XPath是一种节点查找手段。 1、ie中的xpath 在 IE8 及之前的浏览器，XPath 是采用内置基于 ActiveX 的 XML DOM 文档对象实现的。 在每一个节点上提供了两个方法：selectSingleNode()和 selectNodes() var user = xmlDom.selectSingleNode('root/user'); //得到第一个 user 节点 alert(user.xml); //查看 xml 序列 alert(user.tagName); //节点元素名 alert(user.firstChild.nodeValue); //节点内的值 上下文节点：我们通过 xmlDom 这个对象实例调用方法，而 xmlDom 这个对象实例其 实就是一个上下文节点，这个节点指针指向的是根，也 powered by Gitbook该文件修订时间： 2018-09-26 23:35:45 "},"JS/day31/":{"url":"JS/day31/","title":"JSON","keywords":"","body":"JSON 学习要点： JSON语法 解析和序列化 JSON是一种结构化的数据表示方式，其他很多语言都可以对JSON进行解析和序列化 一、JSON语法 表示简单值、对象和数组的值 JSON中的对象 {//除了数字以外必须使用双引号 \"name\" : \"WY\", \"age\" : 18 } JSON中的数组 [100,\"wy\"] 二、解析和序列化 JSON提供两个方法： JSON.parse：将JSON转换为JS原生值 var box = '[{\"name\" : \"a\",\"age\" : 1},{\"name\" : \"b\",\"age\" : 2}]'; //json var json = JSON.parse(box); 第二个参数：可用于替换成自己想要的值 var box = '[{\"name\" : \"a\",\"age\" : 1},{\"name\" : \"b\",\"age\" : 2}]'; var json = JSON.parse(box, function (key, value) { if (key == 'name') { return 'Mr. ' + value; } else { return value; } }); JSON.stringify ：将原生JS值转换为JSON字符串var box = [{name : 'a', age : 1, height : 177},{name : 'b', age : 2, height : 188}]; var json = JSON.stringify(box,['name','age'],4); 第二个参数：过滤结果（显示name 和age 两项） 还可以自定义过滤结果 var box = [{name : 'a', age : 1, height : 177, toJSON : function () { return this.name; }},{name : 'b',age : 2, height : 188, toJSON : function () { return this.name; }}]; 第三个参数：保留缩进 powered by Gitbook该文件修订时间： 2018-09-28 21:20:44 "},"JS/day32/":{"url":"JS/day32/","title":"AJAX","keywords":"","body":"AJAX 学习要点： XMLHttpRequest GET和POST 封装Ajax 一种无刷新提交技术 一、XMLHTTPRequest AJAX技术的核心是XHR对象 //创建xhr对象 var xhr = new XMLHttpRequest(); //调用open方法：表示准备请求（1get方式请求 2请求的URL 3是否同步） xhr.open('get','demo.php',false); //send方法发送请求（get不需要数据请求，则为null） xhr.send(null); 请求发送到服务端后：响应的数据会自动填充XHR对象的以下四个属性： 属性名 说明 responseText 作为响应主体被返回的文本 responseXML 如果响应主体是xml文件，包含 status 响应的HTTP状态 statusText HTTP状态的说明 //可以绑定在点击事件里，只要点击就能实时获得最新的数据 var xhr = new XMLHttpRequest(); xhr.open('get','demo.php',false); xhr.send(null); if(xhr.status == 200){ //成功的状态码：200 alert(xhr.responseText); }else{ //打印服务器返回的数据 alert(xhr.responseText); //2018-03-34 } xhr.abort(); //取消异步请求 异步调用：需要触发readystatechange事件------》检测readyState属性即可，有五个值： var xhr = new createXHR(); xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200) { alert(xhr.responseText); } else { alert('数据返回失败！状态代码：' + xhr.status + '状态信息：' + xhr.statusText); } } }; xhr.open('get', 'demo.php?rand=' + Math.random(), true); xhr.send(null); 二、GET与POST HTTP头信息：服务器返回的响应头信息 和 客户端发送出去的请求头信息。 //获取单个响应头信息 xhr.getResponseHeader('Content-Type'); //获取整个响应头信息 xhr.getAllResponseHeaders(); //设置单个请求头信息 xhr.setResquestHeader('MyHeader','yaoxxx'); GET请求：通过 URL 后的问号给服务器传递键值对数据，特殊字符传参可以使用encodeURIComponent()进行编码处理。 xhr.open('get', 'demo.php?rand=' + Math.random() + '&name=Koo', true); POST请求：通过send方法向服务器提交数据 xhr.send('name=Lee&age=100'); //需要特别的处理 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 三、封装AJAX function ajax(obj) { var xhr = new createXHR(); obj.url = obj.url + '?rand=' + Math.random(); obj.data = params(obj.data); if (obj.method === 'get') obj.url = obj.url.indexOf('?') == -1 ? obj.url + '?' + obj.data : obj.url + '&' + obj.data; if (obj.async === true) { xhr.onreadystatechange = function () { if (xhr.readyState == 4) callback(); }; } xhr.open(obj.method, obj.url, obj.async); if (obj.method === 'post') { xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(obj.data); } else { xhr.send(null); } if (obj.async === false) { callback(); } function callback () { if (xhr.status == 200) { obj.success(xhr.responseText); //回调 } else { alert('数据返回失败！状态代码：' + xhr.status + '， 状态信息：' + xhr.statusText); } } } //调用 ajax addEvent(document, 'click', function () { //IE6 需要重写 addEvent ajax({ method : 'get', url : 'demo.php', data : { 'name' : 'Lee', 'age' : 100 }, success : function (text) { alert(text); }, async : true }); }); //名值对编码 function params(data) { var arr = []; for (var i in data) { arr.push(encodeURIComponent(i) + '=' + encodeURIComponent(data[i])); } return arr.join('&'); } powered by Gitbook该文件修订时间： 2018-09-29 21:58:09 "},"JS/day33/":{"url":"JS/day33/","title":"博客-理解JS库对象","keywords":"","body":"博客前端 学习要点： 项目介绍 理解javascript库 创建基础库 1、模拟博客中前端的那些效果 2、创建基础库 获取节点最常用的方法： 创建一个base.js： var Base = { getId : function(id){ return document.getElementById(id); }; getName : function(name){ return document.getElementByName(name); }; getTagName : function(tag){ return document.getElementByTagName(tag); }; }; 前台调用代码： window.onload = function(){ alert(Base.getId('box').innerHTML); alert(Base.getName('sex')[0].value); alert(Base.getTagName('p')[0].innerHTML); }; 为保证兼容性，采用UTF-8编码格式。 powered by Gitbook该文件修订时间： 2018-09-29 22:07:05 "},"JS/day34/":{"url":"JS/day34/","title":"博客-连缀","keywords":"","body":"博客前端：封装库-连缀 学习要点： 连缀介绍 改写库对象 一、连缀 就是一句话同时设置一个或多个节点以上的操作，比如： $().getId('box').css('color','red').html('标题').click(function(){alert('hello')}); 二、改写库对象 为了实现操作连缀，就需要改写var Base = {}这种写法，这样我们就无法在它的原型中添加方法，就需要使用函数式对象写法： box 段落 段落 段落 /*专门用于返回一个对象*/ var $ = function () { return new Base(); } /*获取一个base对象*/ function Base(){ this.elements = []; //通过id获取节点 this.getId = function (id) { this.elements.push(document.getElementById(id)); return this; }; //通过标签名获取节点 this.getTag = function(tag){ var tags = document.getElementsByTagName(tag); for (var i = 0;i powered by Gitbook该文件修订时间： 2018-10-01 17:37:04 "},"JS/day35/":{"url":"JS/day35/","title":"是否改变原数组的常用方法归纳","keywords":"","body":"是否改变原数组的常用方法归纳 1、改变原数组的： posh、pop、shift、unshift sort、reverse splice、 2、不改变原数组的： concat、join slice slice和splice的区别： splice(i,j,'a')删除、添加元素，splice和slice的作用是不同的，splice会直接对数组进行修改。从i开始删j个，并将a插入到i处。 slice（start,end）从某个已有的数组返回选定的元素，从start位开始返回到end，如果是负数，表示从大户组尾部进行计算，该方法不会修改原数组，而是返回一个子数组。 powered by Gitbook该文件修订时间： 2018-10-10 13:13:59 "},"Git/git.html":{"url":"Git/git.html","title":"Git","keywords":"","body":"删除 远程分支： git push origin --delete 删除本地分支： git branch -d 创建 本地创建分支提交到远程： git push --set-upstream origin 合并冲突之后 add commit 拉取 拉取指定分支的代码：git pull : 设置代理：set http_proxy=http://172.17.18.80:8080 关联 将本地分支与远程分支进行关联： git branch --set-upstream-to=origin/develop yaoxxxyao 推送 git push 主机名 本地分支名 远程分支名 比较 本地分支：diff branchA branchB 远程分支的话，git diff branchA remoteB/branchB 版本切换 版本的切换：git reset --hard commit_id(head^x)（x代表回退几个版本） git log可以查看提交历史，以便确定要回退到哪个版本 git reflog查看命令历史，来确定要回到未来哪个版本 powered by Gitbook该文件修订时间： 2018-12-26 09:50:33 "}}